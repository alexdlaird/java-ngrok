{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p><code>java-ngrok</code> is a Java wrapper for <code>ngrok</code> that manages its own binary, making <code>ngrok</code> available via a convenient Java API.</p> <p><code>ngrok</code> is a reverse proxy that opens secure tunnels from public URLs to localhost. It's perfect for rapid development (test webhooks, demo local websites, enable SSH access), establishing ingress to external networks and devices, building production APIs (traffic policies, OAuth, load balancing), and more. And it's made even more powerful with native Java integration through the <code>java-ngrok</code> client.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>java-ngrok</code> is available on Maven Central.</p> <p>If you want <code>ngrok</code> to be available from the command line, <code>pyngrok</code> can be installed using <code>pip</code> to manage that for you.</p>"},{"location":"#open-a-tunnel","title":"Open a Tunnel","text":"<p>To open a tunnel, use the <code>NgrokClient</code>'s <code>connect()</code> method, which returns a <code>Tunnel</code>, and this returned object has a reference to the public URL generated by <code>ngrok</code>, which can be retrieved with <code>getPublicUrl()</code>.</p> <pre><code>final NgrokClient ngrokClient = new NgrokClient.Builder().build();\n\n// Open a HTTP tunnel on the default port 80\n// &lt;Tunnel: \"https://&lt;public_sub&gt;.ngrok.io\" -&gt; \"http://localhost:80\"&gt;\nfinal Tunnel httpTunnel = ngrokClient.connect();\n\n// Open a SSH tunnel\n// &lt;Tunnel: \"tcp://0.tcp.ngrok.io:12345\" -&gt; \"localhost:22\"&gt;\nfinal CreateTunnel sshCreateTunnel = new CreateTunnel.Builder()\n        .withProto(Proto.TCP)\n        .withAddr(22)\n        .build();\nfinal Tunnel sshTunnel = ngrokClient.connect(sshCreateTunnel);\n\n// Open a named tunnel from the config file\nfinal CreateTunnel createNamedTunnel = new CreateTunnel.Builder()\n        .withName(\"my-config-file-tunnel\")\n        .build();\nfinal Tunnel namedTunnel = ngrokClient.connect(createNamedTunnel);\n\n// Open an Internal Endpoint that's load balanced\n// &lt;Tunnel: \"https://some-endpoint.internal\" -&gt; \"http://localhost:9000\"&gt;\nfinal CreateTunnel createInternalEndpoint = new CreateTunnel.Builder()\n        .withAddr(\"9000\")\n        .withDomain(\"some-endpoint.internal\")\n        .withPoolingEnabled(true)\n        .build();\nfinal Tunnel internalEndpoint = ngrokClient.connect(createInternalEndpoint);\n</code></pre> <p>The <code>connect()</code> method can also take a <code>CreateTunnel</code> (which can be built through its Builder) that allows you to pass additional properties that are supported by <code>ngrok</code> (or <code>withName()</code> to use a tunnel defined in <code>ngrok</code>'s config file), as documented here.</p> <p>Note: <code>ngrok</code> v2's default behavior for <code>http</code> when no additional properties are set is to open two tunnels, one <code>http</code> and one <code>https</code>. <code>java-ngrok</code>s connect method will return a reference to the <code>http</code> tunnel in this case. If only a single tunnel is needed, use <code>withBindTls(true)</code> and a reference to the <code>https</code> tunnel will be returned.</p>"},{"location":"#get-active-tunnels","title":"Get Active Tunnels","text":"<p>It can be useful to ask the <code>ngrok</code> client what tunnels are currently open. This can be accomplished with the <code>getTunnels()</code> method, which returns a list of Tunnel objects.</p> <pre><code>// [&lt;Tunnel: \"https://&lt;public_sub&gt;.ngrok.io\" -&gt; \"http://localhost:80\"&gt;]\nfinal List&lt;Tunnel&gt; tunnels = ngrokClient.getTunnels();\n</code></pre>"},{"location":"#close-a-tunnel","title":"Close a Tunnel","text":"<p>All open tunnels will automatically be closed when the Java process terminates, but we can also close them manually with <code>disconnect(String)</code>.</p> <pre><code>// The Tunnel returned from methods like connect(), getTunnels(), etc. contains the public URL\nngrokClient.disconnect(publicUrl);\n</code></pre>"},{"location":"#expose-other-services","title":"Expose Other Services","text":"<p>Using <code>ngrok</code> you can expose any number of non-HTTP services, for instances databases, game servers, etc. This can be accomplished by using <code>java-ngrok</code> to open a TCP tunnel to the desired service.</p> <pre><code>// Open a tunnel to MySQL with a Reserved TCP Address\n// &lt;NgrokTunnel: \"tcp://1.tcp.ngrok.io:12345\" -&gt; \"localhost:3306\"&gt;\nfinal CreateTunnel mysqlCreateTunnel = new CreateTunnel.Builder()\n        .withProto(Proto.TCP)\n        .withAddr(3306)\n        .withRemoteAddr(\"1.tcp.ngrok.io:12345\")\n        .build();\nfinal Tunnel mysqlTunnel = ngrokClient.connect(mysqlCreateTunnel);\n</code></pre> <p>You can also serve up local directories via <code>ngrok</code>'s built-in fileserver.</p> <pre><code>// Open a tunnel to a local file server\n// &lt;NgrokTunnel: \"https://&lt;public_sub&gt;.ngrok.io\" -&gt; \"file:///\"&gt;\nfinal CreateTunnel fileserverCreateTunnel = new CreateTunnel.Builder()\n        .withAddr(\"file:///\")\n        .build();\nfinal Tunnel fileserverTunnel = ngrokClient.connect(fileserverCreateTunnel);\n</code></pre>"},{"location":"#tunnel-configuration","title":"Tunnel Configuration","text":"<p>It is possible to configure the tunnel when it is created, for instance adding authentication, a subdomain, or other additional tunnel configurations that are supported by <code>ngrok</code>. This is accomplished by using <code>CreateTunnel.Builder</code> to set what properties will be used when the tunnel is created. Here is an example that opens a tunnel with subdomain <code>foo</code>, requires basic authentication for requests, and defines a circuit breaker.</p> <pre><code>final CreateTunnel createTunnel = new CreateTunnel.Builder()\n        .withSubdomain(\"foo\")\n        .withAuth(\"username:password\")\n        .withCircuitBreaker(50)\n        .build();\n\nfinal Tunnel tunnel = ngrokClient.connect(createTunnel);\n</code></pre> <p>If you already have a tunnel defined in <code>ngrok</code>'s config file, you can start it by its name (note that \"-api\" will be appended to its name when started).</p> <pre><code>final CreateTunnel createTunnel = new CreateTunnel.Builder()\n        .withName(\"my-config-file-tunnel\")\n        .build();\n\nfinal Tunnel tunnel = ngrokClient.connect(createTunnel);\n</code></pre>"},{"location":"#ngroks-api","title":"<code>ngrok</code>'s API","text":"<p>The <code>api()</code> method allows you to use the local <code>ngrok</code> agent to make requests against the <code>ngrok</code> API, if you have set an API key. For example, here's how you would reserve a <code>ngrok</code> domain, then create a Cloud Endpoint with an associated traffic policy:</p> <pre><code>final String domain = \"some-domain.ngrok.dev\";\nfinal ApiResponse domainResponse = ngrokClient.api(\n        List.of(\"reserved-domains\", \"create\",\n                \"--domain\", domain));\nfinal ApiResponse endpointResponse = ngrokClient.api(\n        List.of(\"endpoints\", \"create\",\n                \"--bindings\", \"public\",\n                \"--url\", String.format(\"https://%s\", domain),\n                \"--traffic-policy-file\", \"policy.yml\"));\n</code></pre>"},{"location":"#event-logs","title":"Event Logs","text":"<p>When <code>ngrok</code> emits logs, <code>java-ngrok</code> can surface them to a callback function. To register this callback, use <code>JavaNgrokConfig.Builder.withLogEventCallback(Function&lt;NgrokLog, Void&gt;)</code>, as show here:</p> <pre><code>final Function&lt;NgrokLog, Void&gt; logEventCallback = ngrokLog -&gt; {\n    System.out.println(ngrokLog.getLine());\n    return null;\n};\n\nfinal JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withLogEventCallback(logEventCallback)\n        .build();\n\nfinal NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n</code></pre> <p>If these events aren't necessary for your use case, some resources can be freed up by turning them off. <code>JavaNgrokConfig.Builder.withoutMonitoring()</code> will disable logging, or you can call <code>NgrokProcess.ProcessMonitor.stop()</code> to stop monitoring on a running process.</p>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#javangrokconfig","title":"<code>JavaNgrokConfig</code>","text":"<p><code>java-ngrok</code>s interactions with the <code>ngrok</code> binary can be configured using <code>JavaNgrokConfig</code>, which can then be passed to <code>NgrokClient</code>.</p> <pre><code>final JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withRegion(Region.AU)\n        .withMaxLogs(10);\n\nfinal NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n</code></pre> <p>Note: If <code>ngrok</code> is not already installed at <code>JavaNgrokConfig.getNgrokPath</code>, it will be installed the first time most methods in <code>NgrokClient</code> are called.</p> <p>If you need to customize the installation of <code>ngrok</code>, perhaps specifying a timeout, proxy, use a custom mirror for the download, etc., you can do so by leveraging the <code>NgrokInstaller</code>.</p>"},{"location":"#setting-the-authtoken-or-api_key","title":"Setting the <code>authtoken</code> or <code>api_key</code>","text":"<p>Running <code>ngrok</code> with an auth token and API key enables access to more features available on your account (for instance, multiple concurrent tunnels, custom domains, use of Internal Endpoints, etc). You can obtain your auth token and generate API keys from the ngrok dashboard, then install it to ngrok\u2019s config file.</p> <pre><code>final JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withAuthToken(\"&lt;NGROK_AUTHTOKEN&gt;\")\n        .withApiKey(\"&lt;NGROK_API_KEY&gt;\")\n        .build();\n\nfinal NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n</code></pre> <p>You could instead define <code>NGROK_AUTHTOKEN</code> or <code>NGROK_API_KEY</code> as environment variables, if you don\u2019t want to define them in code.</p>"},{"location":"#config-file","title":"Config File","text":"<p>By default, <code>ngrok</code> will look for its config file in the default location. You can override this behavior with <code>JavaNgrokConfig.Builder.withConfigPath(Path)</code>.</p> <pre><code>final JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withConfigPath(Path.of(\"opt\", \"ngrok\", \"config.yml\"))\n        .build();\n\n final NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n</code></pre>"},{"location":"#binary-path","title":"Binary Path","text":"<p>The <code>java-ngrok</code> package manages its own <code>ngrok</code> binary. You can use your <code>ngrok</code> binary if you want by setting it with <code>JavaNgrokConfig.Builder.withNgrokPath(Path)</code> and passing that config to <code>NgrokClient</code>.</p> <pre><code>final JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withNgrokPath(Path.of(\"usr\", \"local\", \"bin\", \"ngrok\"))\n        .build();\n\nfinal NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n</code></pre>"},{"location":"#ngrok-version-compatibility","title":"<code>ngrok</code> Version Compatibility","text":"<p><code>java-ngrok</code> is compatible with <code>ngrok</code> v2 and v3, but by default it will install v3. To install v2 instead, set the version with <code>JavaNgrokConfig.Builder.withNgrokVersion(NgrokVersion)</code> and <code>CreateTunnel.Builder.withNgrokVersion(NgrokVersion)</code>.</p> <pre><code>final JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withNgrokVersion(NgrokVersion.V2)\n        .build();\n\nfinal NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n\n// Open a V2 tunnel\n// &lt;Tunnel: \"http://&lt;public_sub&gt;.ngrok.io\" -&gt; \"http://localhost:80\"&gt;\nfinal CreateTunnel v2Tunnel = new CreateTunnel.Builder()\n        .withNgrokVersion(NgrokVersion.V2)\n        .build();\nfinal Tunnel sshTunnel = ngrokClient.connect(v2Tunnel);\n</code></pre>"},{"location":"#command-line-usage","title":"Command Line Usage","text":"<p>Assuming you have also installed <code>pyngrok</code>, all features of <code>ngrok</code> are available on the command line.</p> <pre><code>ngrok http 80\n</code></pre> <p>For details on how to fully leverage <code>ngrok</code> from the command line, see <code>ngrok</code>'s official documentation.</p>"},{"location":"#java-8","title":"Java 8","text":"<p>A Java 8-compatible build was previously maintained in the <code>1.4.x</code> branch. While it is no longer supported, it is available through the <code>java8-ngrok</code> artifact instead on Maven Central.</p> <p>For more details on what differs in the <code>java8-ngrok</code> dependency, see the \"Java 8\" section of the docs.</p>"},{"location":"integration/","title":"Integration Examples","text":""},{"location":"integration/#spring","title":"Spring","text":"<p>This Spring example includes a <code>Dockerfile</code> to highlight a containerized use case.</p>"},{"location":"integration/#configuration","title":"Configuration","text":"<p>Create a <code>NgrokConfiguration</code> class that lets you use the config to enable <code>ngrok</code> and pass it some useful parameters.</p> <pre><code>@Component\n@Getter\n@Setter\n@ConfigurationProperties(prefix = \"ngrok\")\npublic class NgrokConfiguration {\n    private boolean enabled;\n\n    private String publicUrl;\n}\n</code></pre> <p>And pass parameters to your Spring application through your config file:</p> <pre><code>spring.profiles.active=dev\nngrok.enabled=true\n</code></pre>"},{"location":"integration/#application-integration","title":"Application Integration","text":"<p>If <code>ngrok.enabled</code> config flag is set, <code>java-ngrok</code> will be initialized when Spring is booting. An easy way to do this is by creating a <code>Component</code> with an <code>EventListener</code> that is executed when <code>WebServerInitializedEvent</code> is emitted.</p> <pre><code>@Component\n@Profile(\"dev\")\n@Slf4j\npublic class NgrokWebServerEventListener {\n\n    @Autowired\n    private NgrokConfiguration ngrokConfiguration;\n\n    @EventListener\n    public void onApplicationEvent(final WebServerInitializedEvent event) {\n        // Only install and initialize ngrok if we're actually using it\n        if (ngrokConfiguration.isEnabled()) {\n            final NgrokClient ngrokClient = new NgrokClient.Builder()\n                    .build();\n\n            final int port = event.getWebServer().getPort();\n\n            final CreateTunnel createTunnel = new CreateTunnel.Builder()\n                    .withAddr(port)\n                    .build();\n            final Tunnel tunnel = ngrokClient.connect(createTunnel);\n            final String publicUrl = tunnel.getPublicUrl();\n\n            log.info(String.format(\"ngrok tunnel \\\"%s\\\" -&gt; \\\"http://127.0.0.1:%d\\\"\",publicUrl, port));\n\n            // Update any base URLs or webhooks to use the public ngrok URL\n            ngrokConfiguration.setPublicUrl(publicUrl);\n            initWebhooks(publicUrl);\n        }\n    }\n\n    private void initWebhooks(final String publicUrl) {\n        // ... Implement updates necessary so inbound traffic uses the public-facing ngrok URL\n    }\n}\n</code></pre> <p>Now Spring can be started by the usual means, setting <code>ngrok.enabled</code> in the config to open a tunnel.</p> <ol> <li>Run <code>./gradlew build</code> to build the application</li> <li>Start application with <code>java -jar build/libs/java-ngrok-example-spring-1.0.0-SNAPSHOT.jar</code></li> <li>Check the logs for the <code>ngrok</code> tunnel's public URL, which should tunnel to  <code>http://localhost:8080</code></li> </ol>"},{"location":"integration/#dropwizard","title":"Dropwizard","text":""},{"location":"integration/#configuration_1","title":"Configuration","text":"<p>Create a <code>NgrokConfiguration</code> class that lets you use the config to enable <code>ngrok</code> and pass it some useful parameters.</p> <pre><code>public class NgrokConfiguration {\n    @JsonProperty\n    private boolean enabled = false;\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n}\n</code></pre> <p>Then wire this class as a <code>JsonProperty</code> to the Dropwizard Configuration for your Application.</p> <pre><code>public class JavaNgrokExampleDropwizardConfiguration extends Configuration {\n    @JsonProperty\n    private String environment = \"dev\";\n\n    @JsonProperty(\"ngrok\")\n    private NgrokConfiguration ngrokConfiguration;\n\n    public String getEnvironment() {\n        return environment;\n    }\n\n    public NgrokConfiguration getNgrokConfiguration() {\n        return ngrokConfiguration;\n    }\n}\n</code></pre> <p>And pass parameters to your Dropwizard application through your config file:</p> <pre><code>ngrok:\n  enabled: true\n</code></pre> <p>Now Dropwizard can be started by the usual means, setting <code>ngrok.enabled</code> in the config to open a tunnel.</p> <ol> <li>Run <code>mvn install</code> to build the application</li> <li>Start application with <code>java -jar target/java-ngrok-example-dropwizard-1.0.0-SNAPSHOT.jar server src/main/resources/config.yml</code></li> <li>Check the logs for the <code>ngrok</code> tunnel's public URL, which should tunnel to  <code>http://localhost:8080</code></li> </ol>"},{"location":"integration/#application-integration_1","title":"Application Integration","text":"<p>If <code>ngrok.enabled</code> config flag is set, <code>java-ngrok</code> will be initialized when Dropwizard is booting. An easy place to do this is in the <code>run()</code> method of the Application.</p> <pre><code>public class JavaNgrokExampleDropwizardApplication extends Application&lt;JavaNgrokExampleDropwizardConfiguration&gt; {\n\n    private static final Logger LOGGER = Logger.getLogger(String.valueOf(JavaNgrokExampleDropwizardApplication.class));\n\n    @Override\n    public void run(final JavaNgrokExampleDropwizardConfiguration configuration,\n                    final Environment environment) {\n        // Only install and initialize ngrok if we're actually using it\n        if (configuration.getEnvironment().equals(\"dev\") &amp;&amp;\n                configuration.getNgrokConfiguration().isEnabled()) {\n            final NgrokClient ngrokClient = new NgrokClient.Builder()\n                    .build();\n\n            final int port = getPort(configuration);\n\n            final CreateTunnel createTunnel = new CreateTunnel.Builder()\n                    .withAddr(port)\n                    .build();\n            final Tunnel tunnel = ngrokClient.connect(createTunnel);\n            final String publicUrl = tunnel.getPublicUrl();\n\n            LOGGER.info(String.format(\"ngrok tunnel \\\"%s\\\" -&gt; \\\"http://127.0.0.1:%d\\\"\", publicUrl, port));\n\n            // Update any base URLs or webhooks to use the public ngrok URL\n            configuration.setPublicUrl(publicUrl);\n            initWebhooks(publicUrl);\n        }\n    }\n\n    private int getPort(JavaNgrokExampleDropwizardConfiguration configuration) {\n        final Stream&lt;ConnectorFactory&gt; connectors = configuration.getServerFactory() instanceof DefaultServerFactory\n                ? ((DefaultServerFactory) configuration.getServerFactory()).getApplicationConnectors().stream()\n                : Stream.of((SimpleServerFactory) configuration.getServerFactory()).map(SimpleServerFactory::getConnector);\n\n        return connectors.filter(connector -&gt; connector.getClass().isAssignableFrom(HttpConnectorFactory.class))\n                .map(connector -&gt; (HttpConnectorFactory) connector)\n                .mapToInt(HttpConnectorFactory::getPort)\n                .findFirst()\n                .orElseThrow(IllegalStateException::new);\n    }\n\n    private void initWebhooks(final String publicUrl) {\n        // ... Implement updates necessary so inbound traffic uses the public-facing ngrok URL\n    }\n\n    // ... Implement the rest of your Dropwizard application\n}\n</code></pre>"},{"location":"integration/#play-scala","title":"Play (Scala)","text":""},{"location":"integration/#application-integration_2","title":"Application Integration","text":"<p>Register an eager <code>Singleton</code> in the app's base <code>Module</code>.</p> <pre><code>class Module extends AbstractModule {\n  override def configure(): Unit = {\n    bind(classOf[NgrokApplicationLifecycle]).asEagerSingleton()\n  }\n}\n</code></pre> <p>Then create a <code>NgrokApplicatinLifecycle</code> class. If <code>ngrok.enabled</code> config flag is set, <code>java-ngrok</code> will be initialized when Play is booting in a <code>dev</code> environment.</p> <pre><code>@Singleton\nclass NgrokApplicationLifecycle @Inject()(config: Configuration, lifecycle: ApplicationLifecycle) {\n  private val environment: String = config.getOptional[String](\"environment\").getOrElse(\"production\")\n  private val ngrokEnabled: Boolean = config.getOptional[Boolean](\"ngrok.enabled\").getOrElse(false)\n\n  // Only install and initialize ngrok if we're actually using it\n  if (environment.equals(\"dev\") &amp;&amp; ngrokEnabled) {\n    val ngrokClient: NgrokClient = new NgrokClient.Builder()\n      .build\n\n    val port: Int = config.getOptional[Int](\"http.port\").getOrElse(9000)\n\n    val createTunnel: CreateTunnel = new CreateTunnel.Builder()\n      .withAddr(port)\n      .build\n    val tunnel: Tunnel = ngrokClient.connect(createTunnel)\n\n    println(s\" * ngrok tunnel \\\"${tunnel.getPublicUrl}\\\" -&gt; \\\"http://localhost:$port\\\"\")\n  }\n}\n</code></pre> <p>Pass parameters to your Play application through your config file (including making <code>.ngrok.io</code> an allowed host):</p> <pre><code>ngrok {\n    enabled=true\n}\nplay.filters.hosts {\n  allowed = [\".ngrok.io\", \"localhost:9000\"]\n}\n</code></pre> <p>Now Play can be started by the usual means, setting <code>ngrok.enabled</code> in the config to open a tunnel.</p> <ol> <li>Run <code>sbt compile package</code> to build the application</li> <li>Start application with <code>sbt run</code></li> <li>Check the logs for the <code>ngrok</code> tunnel's public URL, which should tunnel to  <code>http://localhost:9000</code></li> </ol>"},{"location":"integration/#docker","title":"Docker","text":"<p>To use <code>java-ngrok</code> in a container image, it's recommended that you download and install the <code>ngrok</code> binary while building the image. Here is an example <code>Dockerfile</code> that does this:</p> <pre><code>FROM ubuntu:24.04\n\nRUN apt-get update\nRUN apt-get install -y curl openjdk-21-jre-headless\nRUN curl -sSL https://ngrok-agent.s3.amazonaws.com/ngrok.asc \\\n      | tee /etc/apt/trusted.gpg.d/ngrok.asc &gt;/dev/null \\\n      &amp;&amp; echo \"deb https://ngrok-agent.s3.amazonaws.com buster main\" \\\n      | tee /etc/apt/sources.list.d/ngrok.list \\\n      &amp;&amp; apt update \\\n      &amp;&amp; apt install ngrok\n\nRUN mkdir -p /root/.config/ngrok\nRUN echo \"version: 2\\nweb_addr: 0.0.0.0:4040\" &gt;&gt; /root/.config/ngrok/ngrok.yml\n\n# Provision your Java application\nENV NGROK_BINARY_PATH=\"/usr/local/bin/ngrok\"\nCOPY my-java-ngrok-app.jar /root/my-java-ngrok-app.jar\nCMD [\"java\", \"-jar\", \"/root/my-java-ngrok-app.jar\"]\n</code></pre> <p>In the above example, <code>ngrok</code> will be installed to <code>/usr/local/bin/ngrok</code>. You'll need to specify this binary path for <code>ngrok</code> in your Java application to ensure <code>java-ngrok</code>'s installer is bypassed.</p> <pre><code>final JavaNgrokConfig javaNgrokConfig = new JavaNgrokConfig.Builder()\n        .withNgrokPath(Path.of(\"usr\", \"local\", \"bin\", \"ngrok\"))\n        .build();\n\nfinal NgrokClient ngrokClient = new NgrokClient.Builder()\n        .withJavaNgrokConfig(javaNgrokConfig)\n        .build();\n</code></pre> <p>Now build your Java application, then build and launch the container image with:</p> <pre><code># ... Command to build my-java-ngrok-app.jar\ndocker build -t my-java-ngrok .\ndocker run -e NGROK_AUTHTOKEN=$NGROK_AUTHTOKEN -it my-java-ngrok\n</code></pre> <p>If you want to start in a <code>bash</code> shell instead of your Java application, you can launch the container with.</p> <pre><code>docker run -e NGROK_AUTHTOKEN=$NGROK_AUTHTOKEN -it my-java-ngrok /bin/bash\n</code></pre> <p>The <code>java-ngrok-example-spring</code> repository also includes a <code>Dockerfile</code> and <code>make</code> commands to run it, if you would like to see a complete example.</p>"},{"location":"integration/#config-file","title":"Config File","text":"<p><code>ngrok</code> will look for its config file in this container at <code>/root/.config/ngrok/ngrok.yml</code>. If you want to provide a custom config file, specify a mount to this file when launching the container.</p> <pre><code>docker run -v ./ngrok.yml:/root/.config/ngrok/ngrok.yml -it my-java-ngrok\n</code></pre>"},{"location":"integration/#web-inspector","title":"Web Inspector","text":"<p>If you want to use <code>ngrok</code>'s web inspector, be sure to expose its port. Be sure whatever config file you use sets <code>web_addr: 0.0.0.0:4040</code>.</p> <pre><code>docker run --env-file .env -p 4040:4040 -it my-java-ngrok\n</code></pre>"},{"location":"integration/#docker-compose","title":"Docker Compose","text":"<p>You could also launch the container using <code>docker-compose.yml</code>:</p> <pre><code>services:\n  ngrok:\n    image: my-java-ngrok\n    env_file: \".env\"\n    volumes:\n      - ./ngrok.yml:/root/.config/ngrok/ngrok.yml\n    ports:\n      - 4040:4040\n</code></pre> <p>Then launch it with:</p> <pre><code>docker compose up -d\n</code></pre>"},{"location":"integration/#end-to-end-testing","title":"End-to-End Testing","text":"<p>Some testing use-cases might mean you want to temporarily expose a route via a <code>java-ngrok</code> tunnel to fully validate a workflow. For example, an internal end-to-end tester, a step in a pre-deployment validation pipeline, or a service that automatically updates a status page.</p> <p>Whatever the case may be, using JUnit's <code>BeforeAll</code> and <code>AfterAll</code> fixtures are a good place to hook <code>java-ngrok</code> in to your integration tests. This snippet builds on the Dropwizard example above, but it could be modified to work with other frameworks.</p> <pre><code>@ExtendWith(DropwizardExtensionsSupport.class)\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass JavaNgrokTestCase extends TestCase {\n\n    private final static DropwizardAppExtension&lt;JavaNgrokExampleDropwizardConfiguration&gt; dropwizardAppExtension = new DropwizardAppExtension&lt;&gt;(\n        JavaNgrokExampleDropwizardApplication.class,\n        ResourceHelpers.resourceFilePath(\"config.yml\")\n    );\n\n    private NgrokClient ngrokClient;\n\n    private String baseUrl;\n\n    @BeforeAll\n    public void setUpClass() {\n        this.ngrokClient = new NgrokClient.Builder()\n                .build();\n\n        final CreateTunnel createTunnel = new CreateTunnel.Builder()\n                .withAddr(EXT.getLocalPort())\n                .build();\n        final Tunnel tunnel = ngrokClient.connect(createTunnel);\n        this.baseUrl = tunnel.getPublicUrl();\n\n        // ... Implement other initializes so you can assert against the inbound traffic through your tunnel\n    }\n\n    @AfterAll\n    public void tearUpClass() {\n        ngrokClient.kill();\n    }\n}\n</code></pre> <p>Now, any test that needs to assert against responses through a <code>java-ngrok</code> tunnel can simply extend <code>JavaNgrokTestCase</code> to inherit these fixtures.</p>"},{"location":"integration/#simple-http-server","title":"Simple HTTP Server","text":"<p>Java's <code>HttpServer</code> class also makes for a useful development server. You can use <code>java-ngrok</code> to expose it to the web via a tunnel, as shown here:</p> <pre><code>public class NgrokHttpServer {\n\n    private static final Logger LOGGER = Logger.getLogger(String.valueOf(NgrokHttpServer.class));\n\n    public static void main(String[] args) throws Exception {\n        final int port = Integer.parseInt(System.getenv().getOrDefault(\"PORT\", \"80\"));\n\n        final HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n\n        final NgrokClient ngrokClient = new NgrokClient.Builder().build();\n\n        final CreateTunnel createTunnel = new CreateTunnel.Builder()\n                .withAddr(port)\n                .build();\n        final Tunnel tunnel = ngrokClient.connect(createTunnel);\n\n        LOGGER.info(String.format(\"ngrok tunnel \\\"%s\\\" -&gt; \\\"http://127.0.0.1:%d\\\"\", tunnel.getPublicUrl(), port));\n\n        server.start();\n    }\n}\n</code></pre>"},{"location":"integration/#simple-tcp-server-and-client","title":"Simple TCP Server and Client","text":"<p>This example project shows a simple TCP ping/pong server. It opens a local socket, uses <code>ngrok</code> to tunnel to that socket, then the client/server communicate via the publicly exposed address.</p>"}]}